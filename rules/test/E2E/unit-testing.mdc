# Unit Testing Rules - React Native TypeScript

## Overview
Comprehensive unit testing standards for React Native TypeScript projects using Jest and React Native Testing Library. All tests must follow AAA pattern (Arrange, Act, Assert) and maintain high test coverage for critical functionality.

## Test Configuration

### Jest Setup
- **Use Jest** as the primary testing framework
- **Configure React Native Testing Library** for component testing
- **Set up TypeScript support** with `@types/jest`
- **Configure test environment** for React Native
- **Set up coverage reporting** with minimum thresholds

### Required Dependencies
```json
{
  "devDependencies": {
    "@testing-library/react-native": "^12.0.0",
    "@testing-library/jest-native": "^5.0.0",
    "@types/jest": "^29.0.0",
    "jest": "^29.0.0",
    "ts-jest": "^29.0.0"
  }
}
```

## Test Organization

### File Structure
```
src/
├── components/
│   ├── Button/
│   │   ├── Button.tsx
│   │   ├── Button.test.tsx
│   │   └── index.ts
│   └── __tests__/
│       └── components.test.ts
├── screens/
│   ├── HomeScreen/
│   │   ├── HomeScreen.tsx
│   │   ├── HomeScreen.test.tsx
│   │   └── index.ts
│   └── __tests__/
│       └── screens.test.ts
├── hooks/
│   ├── useAuth.ts
│   ├── useAuth.test.ts
│   └── __tests__/
│       └── hooks.test.ts
└── __tests__/
    ├── setup.ts
    ├── mocks/
    └── utils/
```

### Naming Conventions
- **Test files**: `ComponentName.test.tsx` or `ComponentName.spec.tsx`
- **Test suites**: `describe('ComponentName', () => {})`
- **Test cases**: `it('should do something specific', () => {})`
- **Test utilities**: `__tests__/utils/` directory

## Component Testing

### Basic Component Test Structure
```typescript
// ✅ CORRECT: Complete component test
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react-native';
import { Button } from '../Button';

describe('Button', () => {
  // Arrange
  const mockOnPress = jest.fn();
  const defaultProps = {
    title: 'Test Button',
    onPress: mockOnPress,
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should render with correct title', () => {
    // Arrange
    render(<Button {...defaultProps} />);
    
    // Act
    const button = screen.getByText('Test Button');
    
    // Assert
    expect(button).toBeTruthy();
  });

  it('should call onPress when pressed', () => {
    // Arrange
    render(<Button {...defaultProps} />);
    
    // Act
    const button = screen.getByText('Test Button');
    fireEvent.press(button);
    
    // Assert
    expect(mockOnPress).toHaveBeenCalledTimes(1);
  });

  it('should be disabled when disabled prop is true', () => {
    // Arrange
    render(<Button {...defaultProps} disabled={true} />);
    
    // Act
    const button = screen.getByText('Test Button');
    
    // Assert
    expect(button.props.accessibilityState.disabled).toBe(true);
  });
});
```

### Component Test Requirements
- **Test all props** and their effects
- **Test user interactions** (press, scroll, input)
- **Test accessibility** features
- **Test error states** and edge cases
- **Test loading states** if applicable
- **Test conditional rendering**

## Hook Testing

### Custom Hook Test Structure
```typescript
// ✅ CORRECT: Hook testing with renderHook
import { renderHook, act } from '@testing-library/react-native';
import { useCounter } from '../useCounter';

describe('useCounter', () => {
  it('should initialize with default value', () => {
    // Arrange & Act
    const { result } = renderHook(() => useCounter());
    
    // Assert
    expect(result.current.count).toBe(0);
  });

  it('should increment count', () => {
    // Arrange
    const { result } = renderHook(() => useCounter());
    
    // Act
    act(() => {
      result.current.increment();
    });
    
    // Assert
    expect(result.current.count).toBe(1);
  });

  it('should reset count', () => {
    // Arrange
    const { result } = renderHook(() => useCounter());
    
    // Act
    act(() => {
      result.current.increment();
      result.current.increment();
      result.current.reset();
    });
    
    // Assert
    expect(result.current.count).toBe(0);
  });
});
```

### Hook Test Requirements
- **Test initial state** and default values
- **Test all hook methods** and their effects
- **Test state updates** and side effects
- **Test cleanup** functions if applicable
- **Test error handling** in hooks

## API Testing

### Service/API Test Structure
```typescript
// ✅ CORRECT: API service testing
import { PetService } from '../PetService';
import { mockApiClient } from '../__mocks__/apiClient';

jest.mock('../apiClient');

describe('PetService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should fetch pets successfully', async () => {
    // Arrange
    const mockPets = [
      { id: 1, name: 'Fluffy', type: 'cat' },
      { id: 2, name: 'Rex', type: 'dog' },
    ];
    mockApiClient.get.mockResolvedValue({ data: mockPets });

    // Act
    const result = await PetService.getPets();

    // Assert
    expect(result).toEqual(mockPets);
    expect(mockApiClient.get).toHaveBeenCalledWith('/pets');
  });

  it('should handle API errors', async () => {
    // Arrange
    const errorMessage = 'Network error';
    mockApiClient.get.mockRejectedValue(new Error(errorMessage));

    // Act & Assert
    await expect(PetService.getPets()).rejects.toThrow(errorMessage);
  });
});
```

### API Test Requirements
- **Mock external dependencies** (API clients, storage)
- **Test successful responses** and data transformation
- **Test error scenarios** and error handling
- **Test loading states** and async operations
- **Test request parameters** and headers

## Utility Function Testing

### Utility Test Structure
```typescript
// ✅ CORRECT: Utility function testing
import { formatCurrency, validateEmail } from '../utils';

describe('formatCurrency', () => {
  it('should format positive numbers correctly', () => {
    // Arrange & Act
    const result = formatCurrency(1234.56);
    
    // Assert
    expect(result).toBe('$1,234.56');
  });

  it('should handle zero values', () => {
    // Arrange & Act
    const result = formatCurrency(0);
    
    // Assert
    expect(result).toBe('$0.00');
  });

  it('should handle negative values', () => {
    // Arrange & Act
    const result = formatCurrency(-1234.56);
    
    // Assert
    expect(result).toBe('-$1,234.56');
  });
});

describe('validateEmail', () => {
  it('should validate correct email formats', () => {
    // Arrange
    const validEmails = [
      'test@example.com',
      'user.name@domain.co.uk',
      'user+tag@example.org',
    ];

    // Act & Assert
    validEmails.forEach(email => {
      expect(validateEmail(email)).toBe(true);
    });
  });

  it('should reject invalid email formats', () => {
    // Arrange
    const invalidEmails = [
      'invalid-email',
      '@example.com',
      'user@',
      'user@.com',
    ];

    // Act & Assert
    invalidEmails.forEach(email => {
      expect(validateEmail(email)).toBe(false);
    });
  });
});
```

## Mocking Strategies

### Mock Setup
```typescript
// ✅ CORRECT: Comprehensive mocking
// __mocks__/apiClient.ts
export const mockApiClient = {
  get: jest.fn(),
  post: jest.fn(),
  put: jest.fn(),
  delete: jest.fn(),
  interceptors: {
    request: { use: jest.fn() },
    response: { use: jest.fn() },
  },
};

// __mocks__/react-native-keychain.ts
export const Keychain = {
  setInternetCredentials: jest.fn(),
  getInternetCredentials: jest.fn(),
  resetInternetCredentials: jest.fn(),
};

// __mocks__/react-native-async-storage.ts
export const AsyncStorage = {
  setItem: jest.fn(),
  getItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
```

### Mock Requirements
- **Mock external dependencies** consistently
- **Provide realistic mock data** and responses
- **Reset mocks** between tests
- **Test mock interactions** and call counts
- **Use mock factories** for complex objects

## Test Coverage Standards

### Coverage Requirements
- **Minimum 80%** overall coverage
- **Minimum 90%** for critical business logic
- **100% coverage** for utility functions
- **100% coverage** for authentication flows
- **100% coverage** for error handling

### Coverage Configuration
```json
{
  "jest": {
    "collectCoverageFrom": [
      "src/**/*.{ts,tsx}",
      "!src/**/*.d.ts",
      "!src/**/*.test.{ts,tsx}",
      "!src/**/*.spec.{ts,tsx}",
      "!src/__tests__/**"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

## Test Utilities

### Custom Test Utilities
```typescript
// __tests__/utils/test-utils.ts
import React from 'react';
import { render } from '@testing-library/react-native';
import { ThemeProvider } from '../../context/ThemeContext';
import { NavigationContainer } from '@react-navigation/native';

export const renderWithProviders = (
  ui: React.ReactElement,
  options = {}
) => {
  const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
    return (
      <ThemeProvider>
        <NavigationContainer>
          {children}
        </NavigationContainer>
      </ThemeProvider>
    );
  };

  return render(ui, { wrapper: AllTheProviders, ...options });
};

export const createMockUser = (overrides = {}) => ({
  id: '1',
  name: 'Test User',
  email: 'test@example.com',
  ...overrides,
});

export const createMockPet = (overrides = {}) => ({
  id: '1',
  name: 'Fluffy',
  type: 'cat',
  age: 3,
  ...overrides,
});
```

## Error Testing

### Error Boundary Testing
```typescript
// ✅ CORRECT: Error boundary testing
import { render, screen } from '@testing-library/react-native';
import { ErrorBoundary } from '../ErrorBoundary';

const ThrowError = () => {
  throw new Error('Test error');
};

describe('ErrorBoundary', () => {
  beforeEach(() => {
    jest.spyOn(console, 'error').mockImplementation(() => {});
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('should render error UI when child throws', () => {
    // Arrange & Act
    render(
      <ErrorBoundary>
        <ThrowError />
      </ErrorBoundary>
    );

    // Assert
    expect(screen.getByText('Something went wrong')).toBeTruthy();
  });
});
```

## Performance Testing

### Performance Test Structure
```typescript
// ✅ CORRECT: Performance testing
import { render } from '@testing-library/react-native';
import { PetList } from '../PetList';

describe('PetList Performance', () => {
  it('should render large lists efficiently', () => {
    // Arrange
    const largePetList = Array.from({ length: 1000 }, (_, i) => ({
      id: i.toString(),
      name: `Pet ${i}`,
      type: 'dog',
    }));

    // Act
    const startTime = performance.now();
    render(<PetList pets={largePetList} />);
    const endTime = performance.now();

    // Assert
    expect(endTime - startTime).toBeLessThan(100); // Should render in < 100ms
  });
});
```

## Test Data Management

### Test Data Factories
```typescript
// __tests__/factories/petFactory.ts
export const createPet = (overrides = {}) => ({
  id: Math.random().toString(),
  name: 'Test Pet',
  type: 'dog',
  age: 3,
  owner: 'Test Owner',
  ...overrides,
});

export const createPetList = (count = 5) =>
  Array.from({ length: count }, (_, i) =>
    createPet({ id: i.toString(), name: `Pet ${i}` })
  );

// __tests__/factories/userFactory.ts
export const createUser = (overrides = {}) => ({
  id: Math.random().toString(),
  name: 'Test User',
  email: 'test@example.com',
  role: 'user',
  ...overrides,
});
```

## Do's and Don'ts

### ✅ DO's:
- **Follow AAA pattern** (Arrange, Act, Assert)
- **Test all public interfaces** and edge cases
- **Use descriptive test names** that explain the scenario
- **Mock external dependencies** consistently
- **Test error scenarios** and error handling
- **Maintain high test coverage** for critical code
- **Use test utilities** for common setup
- **Test accessibility** features
- **Test performance** for critical components
- **Use TypeScript** in test files for type safety
- **Group related tests** in describe blocks
- **Clean up after tests** (mocks, timers, etc.)

### ❌ DON'Ts:
- **Don't test implementation details** - test behavior
- **Don't skip error scenarios** - they're often critical
- **Don't use magic numbers** - use constants
- **Don't test multiple things** in one test case
- **Don't ignore async operations** - always await
- **Don't forget to reset mocks** between tests
- **Don't test third-party libraries** - mock them
- **Don't write brittle tests** that depend on implementation
- **Don't ignore test performance** - keep tests fast
- **Don't skip integration tests** for critical flows

## Implementation Checklist

### Before Writing Tests:
- [ ] Understand the component/function behavior
- [ ] Identify all public interfaces
- [ ] List all edge cases and error scenarios
- [ ] Plan test data and mock requirements
- [ ] Set up test utilities and helpers

### Test Implementation:
- [ ] Write test structure with AAA pattern
- [ ] Implement all happy path scenarios
- [ ] Add error and edge case tests
- [ ] Test user interactions and events
- [ ] Verify accessibility features
- [ ] Test performance if applicable

### Test Validation:
- [ ] All tests pass consistently
- [ ] Coverage meets minimum requirements
- [ ] Tests are readable and maintainable
- [ ] Error scenarios are properly tested
- [ ] Performance tests are reasonable
- [ ] Integration tests cover critical flows

This comprehensive testing framework ensures high-quality, maintainable, and reliable React Native applications.
description:
globs:
alwaysApply: false
---
