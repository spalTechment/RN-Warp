# Unit Testing Rule for React Native

## Overview
This rule defines comprehensive unit testing standards for React Native business logic, utility functions, state management, and pure functions. It focuses on testing individual functions and logic in isolation.

## Test Categories

### 1. Business Logic Tests
- **Data Transformation**: Test data processing and transformation functions
- **Validation Logic**: Test input validation and business rule enforcement
- **Calculation Functions**: Test mathematical and computational logic
- **State Management**: Test state transitions and business state logic
- **Conditional Logic**: Test complex decision-making and branching logic

### 2. Utility Function Tests
- **Pure Functions**: Test functions with no side effects
- **String Manipulation**: Test text processing and formatting
- **Date/Time Functions**: Test date calculations and formatting
- **Array/Object Operations**: Test data structure manipulations
- **Type Conversion**: Test data type transformations

### 3. State Management Tests
- **Context Logic**: Test context providers and consumers
- **Reducer Functions**: Test state reduction logic
- **Custom Hooks**: Test hook logic and state management
- **State Transitions**: Test state change logic
- **Side Effects**: Test useEffect and other side effect logic

### 4. Validation Tests
- **Input Validation**: Test form validation and data validation
- **Schema Validation**: Test data structure validation
- **Business Rule Validation**: Test domain-specific validation rules
- **Error Handling**: Test error generation and handling logic

## Test Structure Requirements

### Required Imports
```typescript
import { renderHook, act } from '@testing-library/react-native';
import { render } from '@testing-library/react-native';
import React from 'react';
```

### Required Test Setup
```typescript
describe('FunctionName - Unit Testing', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });
});
```

### Required Test Categories
1. **Business Logic Tests** (40% of test cases)
2. **Utility Function Tests** (30% of test cases)
3. **State Management Tests** (20% of test cases)
4. **Validation Tests** (10% of test cases)

## Test Patterns

### Pure Function Pattern
```typescript
describe('Pure Function Tests', () => {
  it('should return correct result for valid input', () => {
    const result = calculateTotal([{ price: 10, quantity: 2 }, { price: 5, quantity: 1 }]);
    
    expect(result).toBe(25);
  });

  it('should handle empty input', () => {
    const result = calculateTotal([]);
    
    expect(result).toBe(0);
  });

  it('should handle edge cases', () => {
    const result = calculateTotal([{ price: 0, quantity: 5 }]);
    
    expect(result).toBe(0);
  });

  it('should not mutate input data', () => {
    const input = [{ price: 10, quantity: 2 }];
    const originalInput = JSON.parse(JSON.stringify(input));
    
    calculateTotal(input);
    
    expect(input).toEqual(originalInput);
  });
});
```

### Validation Function Pattern
```typescript
describe('Validation Function Tests', () => {
  it('should validate correct email format', () => {
    const validEmails = [
      'test@example.com',
      'user.name@domain.co.uk',
      'user+tag@example.org'
    ];
    
    validEmails.forEach(email => {
      expect(validateEmail(email)).toBe(true);
    });
  });

  it('should reject invalid email formats', () => {
    const invalidEmails = [
      'invalid-email',
      '@example.com',
      'user@',
      'user@.com',
      ''
    ];
    
    invalidEmails.forEach(email => {
      expect(validateEmail(email)).toBe(false);
    });
  });

  it('should handle null and undefined inputs', () => {
    expect(validateEmail(null)).toBe(false);
    expect(validateEmail(undefined)).toBe(false);
  });
});
```

### Custom Hook Pattern
```typescript
describe('Custom Hook Tests', () => {
  it('should initialize with default state', () => {
    const { result } = renderHook(() => useCounter());
    
    expect(result.current.count).toBe(0);
    expect(typeof result.current.increment).toBe('function');
    expect(typeof result.current.decrement).toBe('function');
  });

  it('should increment counter', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });

  it('should decrement counter', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.decrement();
    });
    
    expect(result.current.count).toBe(4);
  });

  it('should not go below minimum value', () => {
    const { result } = renderHook(() => useCounter(0, { min: 0 }));
    
    act(() => {
      result.current.decrement();
    });
    
    expect(result.current.count).toBe(0);
  });
});
```

### Context Logic Pattern
```typescript
describe('Context Logic Tests', () => {
  it('should provide initial state', () => {
    const TestComponent = () => {
      const { user, isAuthenticated } = useAuth();
      return (
        <div>
          <span data-testid="user">{user?.name || 'No user'}</span>
          <span data-testid="auth-status">{isAuthenticated ? 'Authenticated' : 'Not authenticated'}</span>
        </div>
      );
    };

    const { getByTestId } = render(
      <AuthProvider>
        <TestComponent />
      </AuthProvider>
    );

    expect(getByTestId('user')).toHaveTextContent('No user');
    expect(getByTestId('auth-status')).toHaveTextContent('Not authenticated');
  });

  it('should update state on login', () => {
    const TestComponent = () => {
      const { login, user, isAuthenticated } = useAuth();
      
      const handleLogin = () => {
        login({ name: 'John Doe', email: 'john@example.com' });
      };

      return (
        <div>
          <button data-testid="login-btn" onPress={handleLogin}>Login</button>
          <span data-testid="user">{user?.name || 'No user'}</span>
          <span data-testid="auth-status">{isAuthenticated ? 'Authenticated' : 'Not authenticated'}</span>
        </div>
      );
    };

    const { getByTestId } = render(
      <AuthProvider>
        <TestComponent />
      </AuthProvider>
    );

    fireEvent.press(getByTestId('login-btn'));

    expect(getByTestId('user')).toHaveTextContent('John Doe');
    expect(getByTestId('auth-status')).toHaveTextContent('Authenticated');
  });
});
```

### Reducer Pattern
```typescript
describe('Reducer Tests', () => {
  it('should handle initial state', () => {
    const initialState = { count: 0, loading: false };
    const action = { type: 'UNKNOWN_ACTION' };
    
    const newState = counterReducer(initialState, action);
    
    expect(newState).toEqual(initialState);
  });

  it('should handle increment action', () => {
    const initialState = { count: 5, loading: false };
    const action = { type: 'INCREMENT' };
    
    const newState = counterReducer(initialState, action);
    
    expect(newState).toEqual({ count: 6, loading: false });
  });

  it('should handle decrement action', () => {
    const initialState = { count: 5, loading: false };
    const action = { type: 'DECREMENT' };
    
    const newState = counterReducer(initialState, action);
    
    expect(newState).toEqual({ count: 4, loading: false });
  });

  it('should handle loading state', () => {
    const initialState = { count: 5, loading: false };
    const action = { type: 'SET_LOADING', payload: true };
    
    const newState = counterReducer(initialState, action);
    
    expect(newState).toEqual({ count: 5, loading: true });
  });
});
```

## Function-Specific Patterns

### Data Transformation Pattern
```typescript
describe('Data Transformation Tests', () => {
  it('should transform API response to UI format', () => {
    const apiResponse = {
      user_id: 123,
      user_name: 'John Doe',
      user_email: 'john@example.com',
      created_at: '2023-01-01T00:00:00Z'
    };
    
    const expected = {
      id: 123,
      name: 'John Doe',
      email: 'john@example.com',
      createdAt: new Date('2023-01-01T00:00:00Z')
    };
    
    const result = transformUserData(apiResponse);
    
    expect(result).toEqual(expected);
  });

  it('should handle missing optional fields', () => {
    const apiResponse = {
      user_id: 123,
      user_name: 'John Doe'
      // email and created_at are missing
    };
    
    const result = transformUserData(apiResponse);
    
    expect(result.id).toBe(123);
    expect(result.name).toBe('John Doe');
    expect(result.email).toBeUndefined();
    expect(result.createdAt).toBeUndefined();
  });
});
```

### Calculation Function Pattern
```typescript
describe('Calculation Function Tests', () => {
  it('should calculate total price correctly', () => {
    const items = [
      { price: 10.99, quantity: 2, discount: 0.1 },
      { price: 5.50, quantity: 1, discount: 0 }
    ];
    
    const result = calculateTotalPrice(items);
    
    expect(result).toBeCloseTo(25.28, 2); // (10.99 * 2 * 0.9) + (5.50 * 1) = 19.78 + 5.50 = 25.28
  });

  it('should handle zero quantities', () => {
    const items = [
      { price: 10, quantity: 0, discount: 0 },
      { price: 5, quantity: 1, discount: 0 }
    ];
    
    const result = calculateTotalPrice(items);
    
    expect(result).toBe(5);
  });

  it('should handle negative prices', () => {
    const items = [
      { price: -10, quantity: 1, discount: 0 }
    ];
    
    expect(() => calculateTotalPrice(items)).toThrow('Price cannot be negative');
  });
});
```

### Date/Time Function Pattern
```typescript
describe('Date/Time Function Tests', () => {
  it('should format date correctly', () => {
    const date = new Date('2023-12-25T10:30:00Z');
    
    const result = formatDate(date, 'MM/DD/YYYY');
    
    expect(result).toBe('12/25/2023');
  });

  it('should calculate time difference', () => {
    const startDate = new Date('2023-12-25T10:00:00Z');
    const endDate = new Date('2023-12-25T11:30:00Z');
    
    const result = calculateTimeDifference(startDate, endDate);
    
    expect(result).toBe(90); // 90 minutes
  });

  it('should handle timezone conversion', () => {
    const utcDate = new Date('2023-12-25T10:00:00Z');
    
    const result = convertToLocalTime(utcDate, 'America/New_York');
    
    expect(result.getHours()).toBe(5); // 5 AM EST
  });
});
```

## Quality Standards

### Coverage Requirements
- **Minimum 95% line coverage** for business logic functions
- **100% coverage** for pure functions
- **100% coverage** for validation functions
- **100% coverage** for edge cases and error conditions

### Performance Requirements
- **Function execution time < 10ms** for simple calculations
- **Function execution time < 50ms** for complex transformations
- **Memory usage** should be constant for pure functions

### Code Quality Requirements
- **Pure functions** should have no side effects
- **Functions should be deterministic** (same input = same output)
- **Error handling** should be comprehensive
- **Type safety** should be maintained

## Test Utilities

### Mock Data Generators
```typescript
const createMockUser = (overrides = {}) => ({
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  createdAt: new Date(),
  ...overrides
});

const createMockOrder = (overrides = {}) => ({
  id: 1,
  userId: 1,
  items: [],
  total: 0,
  status: 'pending',
  createdAt: new Date(),
  ...overrides
});
```

### Test Helpers
```typescript
const testPureFunction = (fn: Function, testCases: Array<{ input: any, expected: any, description?: string }>) => {
  testCases.forEach(({ input, expected, description }) => {
    it(description || `should handle input: ${JSON.stringify(input)}`, () => {
      const result = fn(...input);
      expect(result).toEqual(expected);
    });
  });
};

const testValidationFunction = (fn: Function, validInputs: any[], invalidInputs: any[]) => {
  describe('valid inputs', () => {
    validInputs.forEach(input => {
      it(`should accept: ${JSON.stringify(input)}`, () => {
        expect(fn(input)).toBe(true);
      });
    });
  });

  describe('invalid inputs', () => {
    invalidInputs.forEach(input => {
      it(`should reject: ${JSON.stringify(input)}`, () => {
        expect(fn(input)).toBe(false);
      });
    });
  });
};
```

## Best Practices

### DO's
- **Test pure functions** with multiple input combinations
- **Test edge cases** and boundary conditions
- **Test error conditions** and exception handling
- **Use descriptive test names** that explain the scenario
- **Test one thing per test case** for clarity
- **Mock external dependencies** to isolate the unit under test

### DON'Ts
- **Don't test implementation details** that don't affect behavior
- **Don't test third-party library behavior** directly
- **Don't create complex test setups** for simple functions
- **Don't ignore edge cases** and error conditions
- **Don't test multiple functions** in a single test case

## Integration with Other Rules

### With UI Testing Rule
- Unit tests focus on business logic and pure functions
- UI tests focus on user interactions and rendering
- Unit tests can be used to test logic extracted from UI components

### With API Testing Rule
- Unit tests focus on data transformation and validation
- API tests focus on HTTP communication and service integration
- Unit tests can test API response processing logic

### With Database Testing Rule
- Unit tests focus on data processing and business rules
- Database tests focus on data persistence and queries
- Unit tests can test database result processing logic

This rule ensures comprehensive unit testing that works with any React Native project and can be used independently or in combination with other testing rules.
description:
globs:
alwaysApply: false
---
